'use strict'
//応用課題1：二次方程式ax^2 + bx + c = 0があるとする。ここでa、b、cの値が与えられたとき、xについて実数解を全て出力せよ。
// ヒント1：判別式detは、det = b * b – 4 * a * c;である。
// ヒント2：平方根はMath.sqrt命令で求めることができる。例：const sqRoot = Math.sqrt(2);
// ヒント3：二次方程式の解の公式はx1 = (-b + Math.sqrt(det))/ (2 * a)とx2 = (-b – Math.sqrt(det))/ (2 * a)である。
// 
// 応用課題2：ある整数n＞2が与えられたとき、nが素数ならば「nは素数です」、素数でないならば「nは素数ではありません」とコンソールに表示するプログラムを作成せよ。
// ヒント1：素数とは、1と自分自身以外で割り切れない数のことである。
// ヒント2：素数かどうかを調べるには、nを2からn – 1までの自然数で順番に割っていけばよい。
// ヒント3：あらかじめletで変数isPrimeをtrueで宣言・代入しておき、一回でも条件を満たさなければfalseを代入すると良い。
// ここで面積比＝点の比となり、つまりπr^2:4r^2 = 内部点数:samplesであるので、これをπについて解くと、
// π = 4 * 内部点数 / samplesとなる。
// ヒント1：擬似乱数（ランダムな数）はMath.random()関数で得ることができる。Math.random()は実行するたびに0.0以上1.0未満のランダムな数を返す。これらのことから、以下のように関数を定義すると良い：
// 
// 応用課題3：サンプル数samplesを受け取り、モンテカルロ法を用いて円周率を推定する関数calcPi(samples)を定義せよ。また、実際に関数を実行して、samplesが十分大きなときに3.14に近い値が得られることを確認せよ。
// モンテカルロ法とは、ランダムに値を選択し、その結果を見て確率的に問題を解く方法である。具体的には、円周率を計算するのは以下の方法となる：
// 半径rの円に外接する正方形（1辺あたり2r）の内部にランダムに点を打つ
// ランダムに打たれた点の中で、円の内部に打たれた個数を計測する
// 円の中に打たれた点の数と全ての点の数（samples）の比は、円の面積と正方形の面積の比と一致するはずである
// 面積比「πr^2:4r^2」と点の比「内部点数:samples」から、πを計算する
// 
// 応用課題4：配列はその中に配列を含むことができる。このときの配列を二次元配列という。二次元配列を用いれば数学における行列を表現できる。例えば以下のように作成できる：
// const matrix = [
//   [1, 2],
//   [3, 4]
// ];
// 二次元配列を利用して、適当な数値を含む2×2の行列matrix1とmatrix2を作成し、その和であるmatrixSumを求め、コンソール上に表示せよ。
// ヒント1：二次元配列matrixがあるとき、row行目の配列はmatrix[row]である。row行目の配列のcolumn列目はmatrix[row][column]になる。
// ヒント2：行列の足し算の方法はベクトルと同じである。つまり、同じ位置の値を足せば良い。
// ヒント3：表示は以下のように簡易的なもので良い：
// 
// 応用課題5：プロパティxとプロパティyを持つ、二次元ベクトルを表すVector2クラスを作成せよ。このときVector2クラスは、他のVector2インスタンスとの和を計算して新しいVector2インスタンスを返すadd(other)メソッドと、自身の文字列表現を返すtoString()メソッドを持つこととする。また、実際にいくつかVector2インスタンスを作り、和の計算結果が正しいことを確認せよ。
// ヒント1：add(other)メソッドは、x同士を足したnxとy同士を足したnyを求め、return new Vector2(nx, ny);とすれば良い。
// ヒント2：toString()メソッドが返す文字列表現の内容は自由で良い。ただしxとyの値がわかるようにすること。
//
// 応用課題5：ブログへ記事（Article）を投稿（post）するプログラムが以下のように組まれている：
// // 記事クラス
//// タイトルと内容を持つ
//class Article {
//  constructor(title, text) {
//    this.title = title;
//    this.text = text;
//  }
//}
//
//// ブログクラス
//// 投稿を受け付ける
//class Blog {
//  post(article) {
//    console.log(article.title);
//    console.log(article.text);
//    console.log('ブログに投稿しました！');
//  }
//}
//// 記事を作成する
//const article = new Article('テスト', 'これはテストです');
//// 記事をブログに投稿する
//const blog = new Blog();
//blog.post(article);
//このプログラムに新たにEmailクラスとSNSクラスを追加し、それぞれのクラスに記事を投稿するpost(article)メソッドを追加せよ。ただし、EmailはBlogと同様にtitleとtextの両方を処理できるが、SNSは記事のtitleを処理できない（titleを無視する）ものとする。なお、ここで「投稿」とはコンソールに内容を表示することを指す。
//また、同じ記事をBlog、Email、SNSのそれぞれへ投稿できることを確かめよ。
//ヒント1：EmailクラスはBlogクラスを少し変更するだけでで完成する
//ヒント2：SNSクラスはtitleを無視することに気をつけよう
//
//応用課題6：一般的に、数式を書くときは「1 + 2」のように演算子（記号）を中央に置くが、「1 2 +」のように数字のあとに演算子を置く記法も存在する。これを逆ポーランド記法という。例えば「1 + 2*3 + 4*5」は逆ポーランド記法では「123*+45*+」になる。逆ポーランド記法の文字列から結果を計算する関数を作成し、実際に動作するか確かめよ。ただし、数字は0から9までの1桁のみで、演算子は+と*のみとする。
//ヒント：逆ポーランド記法はスタックを使えば、以下の手順で簡単に計算ができる。
//文字列を先頭から順に見ていく
//数字ならスタックにpushする
//演算子（+や*）ならスタックから2回popし、2つの数値の演算の結果をpushする
//最後に計算結果がスタックに残る
//例えば以下のようになる：
//// 逆ポーランド記法（Reverse Polish Notation）の文字列から
//// 結果を計算する関数
//// ただし数値は1桁（0〜9）のみで、演算子は+と*とする
//function calcRpn(rpnStr) {
//  // スタックを用意する（配列にスタックのメソッドがあるので、ただの配列で良い）
//  const stack = [];
//  // 各文字について
//  for(const character of rpnStr) {
//    //
//    // ここを完成させる
//    //
//  }
//  // 最後にスタックの中に結果だけが残るので、それを返す
//  return stack.pop();
//}
//const rpn1 = '12+3+4+5+'; // 1+2+3+4+5
//const rpn2 = '12+34+*5+'; // (1+2)*(3+4)+5
//const rpn3 = '123*+45*+'; // 1+2*3+4*5
//console.log(calcRpn(rpn1)); // 15
//console.log(calcRpn(rpn2)); // 26
//console.log(calcRpn(rpn3)); // 27
//
//応用課題7：いくつかの頂点（ノード）を辺（エッジ）で結んだもののことをグラフという。地図（交差点が頂点、道が辺）や、SNSでのフォロー/フォロワー関係（アカウントが頂点、フォロー関係が辺）など、現実世界にもグラフは多く存在する。また、データ構造の木もグラフの一種である。辺にはコスト（距離）を付加することができ、地理的な距離などを表すことができる。プログラム上でのグラフの表し方は様々であるが、最もシンプルなのはコストをテーブルで表現した隣接行列である。例えば以下のグラフを隣接行列で表現する。
//すると以下のようになる：
//const graph = [
//  [0, 2, 1], // 頂点0から[頂点0, 頂点1, 頂点2]へのコスト
//  [2, 0, 3], // 頂点1から[頂点0, 頂点1, 頂点2]へのコスト
//  [1, 3, 0]  // 頂点2から[頂点0, 頂点1, 頂点2]へのコスト 
//];
//なお、辺が存在しない場合はコスト「-1」として扱う。ただしマイナスのコストを扱う場面では別の表現方法を考える（※今回はマイナスコストは扱わない）。
//
//このとき、以下のプログラムを参考に、ダイクストラ（Dijkstra）法で最短経路を求めるプログラムを作成せよ：
//// ダイクストラ法により最短経路を算出する
//// graphは隣接行列、startIndexとgoalIndexは頂点番号
//function dijkstra(graph, startIndex, goalIndex) {
//  //
//  // 前準備
//  //
//  const nodeNum = graph.length;        // 配列に入っている配列の数が頂点数
//  const distance = new Array(nodeNum); // スタート地点からの距離表を作成する
//  distance.fill(Infinity);  // 距離を無限大で埋める
//  distance[startIndex] = 0; // ただしスタート地点からスタート地点への距離のみゼロ
//
//  const nodeIndexList = []; // 頂点番号リスト
//  for(let i = 0; i < nodeNum; i++) {
//    nodeIndexList.push(i); // 各頂点番号をリストに入れる
//  }
//
//  const previousNode = new Array(nodeNum); // 前の頂点
//  previousNode.fill(-1); // -1（無効）で埋める
//
//  //
//  // 計算
//  //
//
//  // 頂点番号リストが空でないあいだ
//  while(nodeIndexList.length > 0) {
//    // 頂点番号リストから、スタート地点からの距離が最小の頂点を選ぶ
//    // スタート地点からの総距離はdistance[nodeIndexList[i]]で取得できる
//    // distance[i]がdistance[minDistanceIndex]より小さい番号iを
//    // どんどんminDistanceIndexに入れていけば、最終的に距離が最小のiが得られる
//    let minDistanceIndex = 0;
//    for(let i = 0; i < nodeIndexList.length; i++) {
//      //
//      // 課題：ここを埋める
//      //
//    }
//    const nodeIndex = nodeIndexList[minDistanceIndex];
//    nodeIndexList.splice(minDistanceIndex, 1); // 選んだノードを削除
//
//    // 選んだ頂点（nodeIndex）から繋がっているノードの一覧を作る
//    // 頂点fromから頂点toへの距離はgraph[from][to]で取得できる
//    // 距離が0より大きければ繋がっている
//    // 繋がっていたら番号iをneighbourIndexListに入れる
//    const neighbourIndexList = [];
//    for(let i = 0; i < nodeNum; i++) {
//      //
//      // 課題：ここを埋める
//      //
//    }
//
//    // スタート地点からnIndexまでの現在の総距離（これをAとする）と、
//    // 「スタート地点からnodeIndexまでの総距離」と「nodeIndexからnIndexまでの距離」
//    // を足したもの（これをBとする）を比較して、
//    // Bが小さい場合はdistance[nIndex]をBで更新し、
//    // previousNode[nIndex]にnodeIndexを入れる
//    for(const nIndex of neighbourIndexList) {
//      //
//      // 課題：ここを埋める
//      //
//    }
//  }
//
//  // 答えは出たが人間が読みやすい形式ではないので
//  // ゴールから逆順に辿って最短経路として出す
//  const shortestPath = [goalIndex];
//  for(let prev = previousNode[goalIndex]; prev >= 0; prev = previousNode[prev]) {
//    shortestPath.unshift(prev);
//  }
//
//  return shortestPath;
//  }
