 例題1：円周率を3.14としたとき、半径（radius）が5の円の面積をコンソールに表示するプログラムを書け。
 
 例題2：0から100までの間の数を順番にコンソールに表示せよ。ただし「0は偶数です」「1は奇数です」などというように、偶数奇数のどちらであるかについても表示せよ。
 
 例題3：西暦が与えられたとき、昭和ならば「西暦xxxx年は昭和xx年」、平成ならば「西暦xxxx年は平成xx年」とコンソールに表示するプログラムを作成せよ。ただし与えられる西暦は1930年から2018年までに限るとする。
 
 例題4：2の累乗の値を、0乗から5乗までコンソールに表示せよ。なお累乗は「**」で計算できる。
 
 例題5：数値で西暦を受け取り、平成の数値に変換して返す関数toHeiseiを定義せよ。また、その関数を使って実際にいくつか変換してみよ。ただしここで西暦は1989以上2018以下とする。
 
 例題6：2つの数を受け取り、その差を返す関数subを定義せよ。また、いくつかの数値で実際に関数を使用し、結果を確かめよ。
 
 例題7：整数値nを受け取り、0からnまでの整数をコンソールに出力する関数printNumberを定義せよ。また、実際に関数を使用して結果が正しいことを確かめよ。
 
 例題8：配列[1, 3, 5, 7, 9, 11, 13, 15, 17, 19]と配列[2, 4, 6, 8, 10, 12, 14, 16, 18, 20]を作成し、それぞれのi番目同士の和を配列sumのi番目に格納せよ。また、配列sumをコンソール上に表示せよ。
 
 例題9：新規にオブジェクトrectangle（英語で四角形という意味）を作成し、rectangleに、width（幅）プロパティとheight（高さ）プロパティ、および自身の面積を計算するcalcAreaメソッドを追加せよ。ここでwidthプロパティとheightプロパティの値は任意とする。また、calcAreaメソッドが正常に動作することを確かめよ。
 
 例題10：半径を表すプロパティradiusと、面積を計算するメソッドcalcAreaをを持つクラスCircleを作成せよ。また、実際にいくつかインスタンスを生成し、面積計算が正しいか確かめよ。ただし円周率にはMath.PIを使用すること。
 
 例題11 : 空の配列を作り、その配列にランダムな数値100個を格納し、ひとつずつコンソール上に表示せよ。なおランダムな数はMath.ramdom()メソッドで生成することができる。
 
 例題12：プロパティとして実部reと虚部imを含む、複素数を表すオブジェクトを作成せよ。ここでreとimの値は適当なもので良い。次にこのオブジェクトにメソッドtoString()を追加し、’5+3i’のような文字列に変換する機能をつけよ。また、toString()メソッドを用いて実際に文字列として表示せよ。
 
 例題13：生徒の名前と数学の点数を格納した、以下の配列が与えられているとする：
 const scores = [
   { name: '田中', math: 67 },
   { name: '鈴木', math: 92 },
   { name: '佐藤', math: 51 }
 ];
 このとき各生徒の成績を「田中の数学の点数は67点です」などと表示せよ。

 例題14：以下のような本を表すクラスBookと本棚を表すクラスBookshelfがある：
 // 本を表すクラス
class Book {
  constructor(title, author) {
    this.title = title;
    this.author = author;
  }
}

// 本棚を表すクラス
class Bookshelf {
  constructor() {
    this._books = [];
  }

  // 本棚に本を追加するメソッド
  addBook(book) {
    this._books.push(book);
  }
}
このときBookshelfクラスに、本を検索して初めの結果を返すメソッドsearch(query)を追加せよ。なお、検索は文字列queryがタイトルか著者に含まれているものを一致したとみなす。また、実際に本棚にいくつか本を追加し、検索が機能することを確かめよ。
ヒント：ある文字列に他の文字列が含まれているか調べるには、’文字列’.includes(‘他の文字列’)を使用する。

例題15：二次元ベクトルを表すクラスVector2と、複素数を表すクラスComplexを作成し、文字列表現を返すメソッドtoStringを2つのクラスに追加せよ。また、実際に各クラスのインスタンスを作成し、toStringが正しく動作することを確かめよ。

例題16例題：Math.random()でランダムな数値を100万個作り、配列と二分探索木に数値を追加せよ。次に、配列と二分探索木それぞれから値「2」を探し、探索にかかったステップ数をカウントして表示せよ。

例題17：大量のランダムな要素（1万個以上）を持つ配列を用意し、バブルソートとクイックソートの実行時間を比較せよ。

例題18：スタックというデータ構造がある。スタックは配列のようにデータを蓄積するが、積み上げ（push）と、一番最後にpushされたデータの積み下ろし（pop）の2種類しか操作が存在しない。Stackクラスを実装せよ。また、Stackクラスを実際に使用してみよ。
 
例題19：ソート済みの配列があるとする。このとき、配列の中からある値を探しだす方法として、二分探索（バイナリサーチ）という手法が使える。
配列の真ん中の値を見て、同じならtrueを返し終了する。真ん中より小さければ左半分を二分探索し、真ん中より大きければ右半分を二分探索する。
最後まで見つからなければfalseを返す
これを実装し、動作を確かめよ。

 課題1：0から23までのいずれかの値である整数hourを考える。このときhourが0から11までのときは「午前xx時です」、12のときは「正午です」、13から23までのときは「午後xx時です」と表示するプログラムを作成せよ。また、hourの値を様々に変えてプログラムが正しく動作していることを確かめよ。
 
 課題2：1から100までの数をコンソールに列挙せよ。ただし3の倍数のときだけは頭が悪くなって数字を出力できないものとする。
 
 課題3：日数dを受け取り秒数に換算した値を返す関数dayToSecを定義せよ。また、いくつかの値で計算結果が正しいことを確かめよ。
 
 課題4：整数limit未満の素数を列挙する関数listPrimes(limit)を定義せよ。また、実際に関数を利用して出力が正しいことを確かめよ。
 ヒント：関数listPrimesの中で全て処理するのではなく、素数判定をする関数isPrime(n)を定義し、listPrimesの中からisPrimeを利用すると良い。
 
 課題5：数値のみを含む、同じ長さの配列arrayAとarrayBが以下のように与えられているとする：
 const arrayA = [1, 3, 5, 7, 9];
 const arrayB = [2, 4, 6, 8, 10];
 このときarrayAのi番目とarrayBのi番目を掛けた数値を、新しい配列prodのi番目に格納して、配列prodをコンソールに表示せよ。また、arrayAとarrayBの値や長さをいろいろ変えて、計算結果が正しいことを確かめよ。
 ヒント1：配列prodの作り方は、あらかじめarrayA.lengthの長さを持つ配列を作るか、空の配列を作成してpushしていくか、好きに選ぶと良い。
 ヒント2：例えばprod[0]にはarrayA[0] * arrayB[0]が入る。
 
 課題5：プロパティfirstNameとプロパティlastName、およびプロパティfullNameを持つPersonクラスを作成せよ。次にPersonクラスのインスタンスを作成し、fullNameをコンソール上に表示せよ。
 ヒント：Personクラスのコンストラクタはconstructor(firstName, lastName, fullName)でもいいが、constructor(firstName, lastName)にして、fullNameはlastNameとfirstNameの結合で算出することもできる。

 課題6：課題5で作成したPersonクラスのインスタンスを、配列に3つほど格納せよ。また、格納したインスタンスのfullNameを順にコンソール上に表示せよ。

 課題7：通貨を変換するクラスCurrencyConverterを作成せよ。CurrencyConverterはメソッドdollarToYen(dollar)とeuroToYen(euro)を持つものとする。ただし1ドル＝110円、1ユーロ＝135円とする。また、CurrencyConverterのインスタンスを作成し、正しく動作することを確かめよ。

課題8：キュー（Queue）というデータ構造がある。キューは値を追加するenqueueと、一番古い値を取り出すdequeueの操作を持つ、一方通行のデータ構造である。Queueクラスを作成し、実際に使用してみよ。
ヒント1:：キューは「待ち行列」とも呼ばれる。早く並んだものほど早く出ることができる
ヒント2：JavaScriptの配列には、先頭に値を追加するunshiftメソッド、最後の要素を取り出すpopメソッドがある。

課題9：配列の値を大きい順（例えば[5, 4, 3, 2, 1]）にソートする関数を作成し、適当な配列で動作を確認せよ。使用するアルゴリズムは任意とする。
ヒント：ソート時の比較を逆にすると……？

 応用課題1：二次方程式ax^2 + bx + c = 0があるとする。ここでa、b、cの値が与えられたとき、xについて実数解を全て出力せよ。
 ヒント1：判別式detは、det = b * b – 4 * a * c;である。
 ヒント2：平方根はMath.sqrt命令で求めることができる。例：const sqRoot = Math.sqrt(2);
 ヒント3：二次方程式の解の公式はx1 = (-b + Math.sqrt(det))/ (2 * a)とx2 = (-b – Math.sqrt(det))/ (2 * a)である。
 
 応用課題2：ある整数n＞2が与えられたとき、nが素数ならば「nは素数です」、素数でないならば「nは素数ではありません」とコンソールに表示するプログラムを作成せよ。
 ヒント1：素数とは、1と自分自身以外で割り切れない数のことである。
 ヒント2：素数かどうかを調べるには、nを2からn – 1までの自然数で順番に割っていけばよい。
 ヒント3：あらかじめletで変数isPrimeをtrueで宣言・代入しておき、一回でも条件を満たさなければfalseを代入すると良い。
 ここで面積比＝点の比となり、つまりπr^2:4r^2 = 内部点数:samplesであるので、これをπについて解くと、
 π = 4 * 内部点数 / samplesとなる。
 ヒント1：擬似乱数（ランダムな数）はMath.random()関数で得ることができる。Math.random()は実行するたびに0.0以上1.0未満のランダムな数を返す。これらのことから、以下のように関数を定義すると良い：
 
 応用課題3：サンプル数samplesを受け取り、モンテカルロ法を用いて円周率を推定する関数calcPi(samples)を定義せよ。また、実際に関数を実行して、samplesが十分大きなときに3.14に近い値が得られることを確認せよ。
 モンテカルロ法とは、ランダムに値を選択し、その結果を見て確率的に問題を解く方法である。具体的には、円周率を計算するのは以下の方法となる：
 半径rの円に外接する正方形（1辺あたり2r）の内部にランダムに点を打つ
 ランダムに打たれた点の中で、円の内部に打たれた個数を計測する
 円の中に打たれた点の数と全ての点の数（samples）の比は、円の面積と正方形の面積の比と一致するはずである
 面積比「πr^2:4r^2」と点の比「内部点数:samples」から、πを計算する
 
 応用課題4：配列はその中に配列を含むことができる。このときの配列を二次元配列という。二次元配列を用いれば数学における行列を表現できる。例えば以下のように作成できる：
 const matrix = [
   [1, 2],
   [3, 4]
 ];
 二次元配列を利用して、適当な数値を含む2×2の行列matrix1とmatrix2を作成し、その和であるmatrixSumを求め、コンソール上に表示せよ。
 ヒント1：二次元配列matrixがあるとき、row行目の配列はmatrix[row]である。row行目の配列のcolumn列目はmatrix[row][column]になる。
 ヒント2：行列の足し算の方法はベクトルと同じである。つまり、同じ位置の値を足せば良い。
 ヒント3：表示は以下のように簡易的なもので良い：
 
 応用課題5：プロパティxとプロパティyを持つ、二次元ベクトルを表すVector2クラスを作成せよ。このときVector2クラスは、他のVector2インスタンスとの和を計算して新しいVector2インスタンスを返すadd(other)メソッドと、自身の文字列表現を返すtoString()メソッドを持つこととする。また、実際にいくつかVector2インスタンスを作り、和の計算結果が正しいことを確認せよ。
 ヒント1：add(other)メソッドは、x同士を足したnxとy同士を足したnyを求め、return new Vector2(nx, ny);とすれば良い。
 ヒント2：toString()メソッドが返す文字列表現の内容は自由で良い。ただしxとyの値がわかるようにすること。

 応用課題5：ブログへ記事（Article）を投稿（post）するプログラムが以下のように組まれている：
 // 記事クラス
// タイトルと内容を持つ
class Article {
  constructor(title, text) {
    this.title = title;
    this.text = text;
  }
}

// ブログクラス
// 投稿を受け付ける
class Blog {
  post(article) {
    console.log(article.title);
    console.log(article.text);
    console.log('ブログに投稿しました！');
  }
}
// 記事を作成する
const article = new Article('テスト', 'これはテストです');
// 記事をブログに投稿する
const blog = new Blog();
blog.post(article);
このプログラムに新たにEmailクラスとSNSクラスを追加し、それぞれのクラスに記事を投稿するpost(article)メソッドを追加せよ。ただし、EmailはBlogと同様にtitleとtextの両方を処理できるが、SNSは記事のtitleを処理できない（titleを無視する）ものとする。なお、ここで「投稿」とはコンソールに内容を表示することを指す。
また、同じ記事をBlog、Email、SNSのそれぞれへ投稿できることを確かめよ。
ヒント1：EmailクラスはBlogクラスを少し変更するだけでで完成する
ヒント2：SNSクラスはtitleを無視することに気をつけよう

応用課題6：一般的に、数式を書くときは「1 + 2」のように演算子（記号）を中央に置くが、「1 2 +」のように数字のあとに演算子を置く記法も存在する。これを逆ポーランド記法という。例えば「1 + 2*3 + 4*5」は逆ポーランド記法では「123*+45*+」になる。逆ポーランド記法の文字列から結果を計算する関数を作成し、実際に動作するか確かめよ。ただし、数字は0から9までの1桁のみで、演算子は+と*のみとする。
ヒント：逆ポーランド記法はスタックを使えば、以下の手順で簡単に計算ができる。
文字列を先頭から順に見ていく
数字ならスタックにpushする
演算子（+や*）ならスタックから2回popし、2つの数値の演算の結果をpushする
最後に計算結果がスタックに残る
例えば以下のようになる：
// 逆ポーランド記法（Reverse Polish Notation）の文字列から
// 結果を計算する関数
// ただし数値は1桁（0〜9）のみで、演算子は+と*とする
function calcRpn(rpnStr) {
  // スタックを用意する（配列にスタックのメソッドがあるので、ただの配列で良い）
  const stack = [];
  // 各文字について
  for(const character of rpnStr) {
    //
    // ここを完成させる
    //
  }
  // 最後にスタックの中に結果だけが残るので、それを返す
  return stack.pop();
}
const rpn1 = '12+3+4+5+'; // 1+2+3+4+5
const rpn2 = '12+34+*5+'; // (1+2)*(3+4)+5
const rpn3 = '123*+45*+'; // 1+2*3+4*5
console.log(calcRpn(rpn1)); // 15
console.log(calcRpn(rpn2)); // 26
console.log(calcRpn(rpn3)); // 27

応用課題7：いくつかの頂点（ノード）を辺（エッジ）で結んだもののことをグラフという。地図（交差点が頂点、道が辺）や、SNSでのフォロー/フォロワー関係（アカウントが頂点、フォロー関係が辺）など、現実世界にもグラフは多く存在する。また、データ構造の木もグラフの一種である。辺にはコスト（距離）を付加することができ、地理的な距離などを表すことができる。プログラム上でのグラフの表し方は様々であるが、最もシンプルなのはコストをテーブルで表現した隣接行列である。例えば以下のグラフを隣接行列で表現する。
すると以下のようになる：
const graph = [
  [0, 2, 1], // 頂点0から[頂点0, 頂点1, 頂点2]へのコスト
  [2, 0, 3], // 頂点1から[頂点0, 頂点1, 頂点2]へのコスト
  [1, 3, 0]  // 頂点2から[頂点0, 頂点1, 頂点2]へのコスト 
];
なお、辺が存在しない場合はコスト「-1」として扱う。ただしマイナスのコストを扱う場面では別の表現方法を考える（※今回はマイナスコストは扱わない）。

このとき、以下のプログラムを参考に、ダイクストラ（Dijkstra）法で最短経路を求めるプログラムを作成せよ：
// ダイクストラ法により最短経路を算出する
// graphは隣接行列、startIndexとgoalIndexは頂点番号
function dijkstra(graph, startIndex, goalIndex) {
  //
  // 前準備
  //
  const nodeNum = graph.length;        // 配列に入っている配列の数が頂点数
  const distance = new Array(nodeNum); // スタート地点からの距離表を作成する
  distance.fill(Infinity);  // 距離を無限大で埋める
  distance[startIndex] = 0; // ただしスタート地点からスタート地点への距離のみゼロ

  const nodeIndexList = []; // 頂点番号リスト
  for(let i = 0; i < nodeNum; i++) {
    nodeIndexList.push(i); // 各頂点番号をリストに入れる
  }

  const previousNode = new Array(nodeNum); // 前の頂点
  previousNode.fill(-1); // -1（無効）で埋める

  //
  // 計算
  //

  // 頂点番号リストが空でないあいだ
  while(nodeIndexList.length > 0) {
    // 頂点番号リストから、スタート地点からの距離が最小の頂点を選ぶ
    // スタート地点からの総距離はdistance[nodeIndexList[i]]で取得できる
    // distance[i]がdistance[minDistanceIndex]より小さい番号iを
    // どんどんminDistanceIndexに入れていけば、最終的に距離が最小のiが得られる
    let minDistanceIndex = 0;
    for(let i = 0; i < nodeIndexList.length; i++) {
      //
      // 課題：ここを埋める
      //
    }
    const nodeIndex = nodeIndexList[minDistanceIndex];
    nodeIndexList.splice(minDistanceIndex, 1); // 選んだノードを削除

    // 選んだ頂点（nodeIndex）から繋がっているノードの一覧を作る
    // 頂点fromから頂点toへの距離はgraph[from][to]で取得できる
    // 距離が0より大きければ繋がっている
    // 繋がっていたら番号iをneighbourIndexListに入れる
    const neighbourIndexList = [];
    for(let i = 0; i < nodeNum; i++) {
      //
      // 課題：ここを埋める
      //
    }

    // スタート地点からnIndexまでの現在の総距離（これをAとする）と、
    // 「スタート地点からnodeIndexまでの総距離」と「nodeIndexからnIndexまでの距離」
    // を足したもの（これをBとする）を比較して、
    // Bが小さい場合はdistance[nIndex]をBで更新し、
    // previousNode[nIndex]にnodeIndexを入れる
    for(const nIndex of neighbourIndexList) {
      //
      // 課題：ここを埋める
      //
    }
  }

  // 答えは出たが人間が読みやすい形式ではないので
  // ゴールから逆順に辿って最短経路として出す
  const shortestPath = [goalIndex];
  for(let prev = previousNode[goalIndex]; prev >= 0; prev = previousNode[prev]) {
    shortestPath.unshift(prev);
  }

  return shortestPath;
  }
